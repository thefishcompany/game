<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Midnight Phantasm - The Long Escape</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700&family=Creepster&display=swap');
        body { margin: 0; background: #000; overflow: hidden; color: white; font-family: 'Nanum Gothic', sans-serif; user-select: none; }
        
        /* ğŸ’¡ ì‹œì‘ í™”ë©´ UI */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: radial-gradient(circle, #1a1a1a 0%, #000000 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        #title-main { font-family: 'Creepster', 'Nanum Gothic', cursive; font-size: 6rem; color: #ff4444; text-shadow: 0 0 20px red; margin-bottom: 10px; letter-spacing: 5px; }
        #title-sub { font-size: 1.5rem; color: #aaa; margin-bottom: 50px; }
        .start-btn { 
            padding: 15px 40px; font-size: 1.5rem; font-weight: bold; color: #fff; background: transparent; 
            border: 2px solid #ff4444; border-radius: 5px; cursor: pointer; transition: 0.3s; 
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
        }
        .start-btn:hover { background: #ff4444; color: #000; box-shadow: 0 0 30px red; }

        /* ì¸ê²Œì„ UI */
        #game-container { position: relative; width: 100vw; height: 100vh; display: none; }
        canvas { position: absolute; top: 0; left: 0; }
        #lightCanvas { pointer-events: none; } 

        #ui-layer { position: absolute; top: 15px; left: 15px; z-index: 10; text-shadow: 1px 1px 2px black; color: #aaa; font-size: 0.9rem; }
        #weapon-status { color: #ffeb3b; font-weight: bold; font-size: 1.2rem; margin-top: 10px; display: none; }
        #mission-status { color: #00ffcc; font-weight: bold; font-size: 1.2rem; margin-top: 5px; }
        
        #timer-box { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); color: #ffeb3b; font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 15px #ffeb3b; display: none; z-index: 15; }
        #warning-box { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); color: #ff4444; font-size: 4rem; font-weight: bold; text-shadow: 0 0 30px red; display: none; z-index: 15; animation: blinkWarning 0.3s infinite alternate; pointer-events: none; }
        @keyframes blinkWarning { from { opacity: 1; transform: translateX(-50%) scale(1); } to { opacity: 0.2; transform: translateX(-50%) scale(1.1); } }

        #dialogue-box { 
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); 
            width: 80%; max-width: 800px; height: 150px; background: rgba(0, 10, 20, 0.9); 
            border: 2px solid #aaa; border-radius: 5px; padding: 20px; box-sizing: border-box; 
            cursor: pointer; display: flex; flex-direction: column; z-index: 20; display: none;
        }
        #speaker-name { font-size: 1.2rem; font-weight: bold; margin-bottom: 10px; flex-shrink: 0; }
        #dialogue-text { font-size: 1.1rem; line-height: 1.6; word-break: keep-all; white-space: pre-wrap; overflow-y: auto; }
        
        #interaction-prompt { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2rem; font-weight: bold; color: #ffeb3b; text-shadow: 0 0 10px black; display: none; z-index: 15; pointer-events: none; }
    </style>
</head>
<body>

    <div id="start-screen">
        <div id="title-main">NIGHTMARE SCHOOL</div>
        <div id="title-sub">The Long Escape - ê±°ëŒ€ ë¯¸ê¶ì˜ ë¹„ë°€</div>
        <button class="start-btn" onclick="initGame()">[ ê²Œì„ ì‹œì‘ ]</button>
        <p style="margin-top:20px; color:#666;">â€» ì†Œë¦¬ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ìŠ¤í”¼ì»¤ë¥¼ ì¼œì£¼ì„¸ìš”.</p>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <canvas id="lightCanvas"></canvas>

        <div id="ui-layer">
            <div>ë‚˜ì´íŠ¸ë©”ì–´ ìŠ¤ì¿¨ | ì‹¬ì—°ì˜ ê±°ëŒ€ ë¯¸ê¶</div>
            <div id="controls-info" style="color: #00ffcc; margin-top: 10px;">[W,A,S,D] ì´ë™ | [ë§ˆìš°ìŠ¤] ì¡°ì¤€ | [ì¢Œí´ë¦­ ê¾¹] ì‚¬ê²© | [E] ì¡°ì‚¬</div>
            <div id="mission-status">ëª©í‘œ: ëì—†ì´ ì´ì–´ì§„ êµì‹¤ë“¤ì„ ìˆ˜ìƒ‰í•´ [ë¬´ê¸°]ë¥¼ ì°¾ìœ¼ì„¸ìš”.</div>
            <div id="weapon-status">ë¬´ê¸°: ì—†ìŒ</div>
        </div>

        <div id="timer-box">60.00</div>
        <div id="warning-box">ë„ë§ì³!!! (ì‹œì‘ ì§€ì ìœ¼ë¡œ)</div>
        <div id="interaction-prompt">[E] í‚¤ë¥¼ ëˆŒëŸ¬ ì¡°ì‚¬í•˜ê¸°</div>

        <div id="dialogue-box">
            <div id="speaker-name"></div>
            <div id="dialogue-text"></div>
        </div>
    </div>

    <script>
        // === 1. ì›¹ ì˜¤ë””ì˜¤ (ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ) ===
        let audioCtx;
        let bgmOscillator;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            // ë°°ê²½ìŒ (ë¶ˆì¾Œí•œ ì €ìŒ ì›…ì›…ê±°ë¦¼)
            bgmOscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();
            bgmOscillator.type = 'sine';
            bgmOscillator.frequency.setValueAtTime(45, audioCtx.currentTime); // ì•„ì£¼ ë‚®ì€ ì €ìŒ
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            bgmOscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            bgmOscillator.start();
        }

        // ì´ì†Œë¦¬ (í™”ì´íŠ¸ ë…¸ì´ì¦ˆ í•©ì„±)
        function playShootSound() {
            if(!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 0.1; // 0.1ì´ˆ
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            noise.connect(gain); gain.connect(audioCtx.destination);
            noise.start();
        }

        // ê´´ë¬¼ ë¹„ëª…ì†Œë¦¬
        function playScreamSound() {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 1); // ì†Œë¦„ë¼ì¹˜ê²Œ ë–¨ì–´ì§€ëŠ” ìŒ
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 1);
        }

        // === 2. ìº”ë²„ìŠ¤ ë° ê²Œì„ ë³€ìˆ˜ ===
        const gameCanvas = document.getElementById("gameCanvas");
        const ctx = gameCanvas.getContext("2d");
        const lightCanvas = document.getElementById("lightCanvas");
        const lightCtx = lightCanvas.getContext("2d");

        function resize() {
            gameCanvas.width = lightCanvas.width = window.innerWidth;
            gameCanvas.height = lightCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        let gameState = "START"; 
        
        // ì´ë™ ì†ë„ ì„¤ì • (ë§µì´ í¬ë‹ˆê¹Œ ì¢€ ë” ë¹ ë¥´ê²Œ)
        const player = { x: 0, y: 0, radius: 15, speed: 8, hasWeapon: false };
        const camera = { x: 0, y: 0 }; 
        const keys = {};
        const mouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
        const bullets = []; 
        const monsters = [];

        let isMouseDown = false;
        let lastShotTime = 0;
        const fireRate = 80; // ì—°ì‚¬ì†ë„ ë§¤ìš° ë¹ ë¦„

        let isSurvivalActive = false; let survivalStartTime = 0; let lastSpawnTime = 0;
        let isChaseActive = false; 

        window.addEventListener("keydown", (e) => keys[e.code] = true);
        window.addEventListener("keyup", (e) => keys[e.code] = false);
        window.addEventListener("mousemove", (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener("mousedown", () => { if(gameState === "EXPLORE") isMouseDown = true; });
        window.addEventListener("mouseup", () => isMouseDown = false);

        const dialogueBox = document.getElementById("dialogue-box");
        const speakerEl = document.getElementById("speaker-name");
        const textEl = document.getElementById("dialogue-text");
        const promptEl = document.getElementById("interaction-prompt");
        const weaponStatus = document.getElementById("weapon-status");
        const missionStatus = document.getElementById("mission-status");
        const warningBox = document.getElementById("warning-box");
        const timerBox = document.getElementById("timer-box");

        // === 3. ê±°ëŒ€ ë§µ ìƒì„±ê¸° (Procedural Generation) ===
        let walls = [];
        let labels = []; // ë°”ë‹¥ì— ê·¸ë ¤ì§ˆ ê¸€ì”¨ë“¤
        let interactables = [];

        function buildHugeMap() {
            // [A] ë©”ì¸ ë³µë„ (ê¸¸ì´ 15000 í”½ì…€)
            walls.push({ id: "wall", x: -500, y: -200, w: 16000, h: 50 }); // ìƒë‹¨ í…Œë‘ë¦¬
            walls.push({ id: "wall", x: -500, y: 800, w: 16000, h: 50 });  // í•˜ë‹¨ í…Œë‘ë¦¬
            walls.push({ id: "wall", x: -500, y: -200, w: 50, h: 1050 });  // ì™¼ìª½ ë§‰íŒ ë²½ (ì‹œì‘ì )
            walls.push({ id: "wall", x: 15500, y: -200, w: 50, h: 1050 }); // ì˜¤ë¥¸ìª½ ë§‰íŒ ë²½ (ì¢…ì )

            // ë³µë„ë¥¼ ê°€ë¡œì§€ë¥´ëŠ” ì¤‘ê°„ ë²½ (êµì‹¤ ë§Œë“¤ê¸°)
            walls.push({ id: "wall", x: 0, y: 350, w: 15000, h: 50 }); // ë³µë„ ì•„ë˜ìª½ ì„ 

            // [B] 1ë°˜ë¶€í„° 10ë°˜ê¹Œì§€ êµì‹¤ ë¬´í•œ ìƒì„±! (ë£¨í”„ ì‚¬ìš©)
            for(let i=0; i<10; i++) {
                let startX = 500 + (i * 1200); // 1200í”½ì…€ë§ˆë‹¤ êµì‹¤ í•˜ë‚˜
                
                // êµì‹¤ ì™¼ìª½/ì˜¤ë¥¸ìª½ ë²½
                walls.push({ id: "wall", x: startX, y: -200, w: 50, h: 550 });
                // êµì‹¤ ë²ˆí˜¸ ë°”ë‹¥ì— ìƒˆê¸°ê¸°
                labels.push({ text: `1í•™ë…„ ${i+1}ë°˜`, x: startX + 400, y: 200, size: 60, color: "rgba(255,255,255,0.2)" });
                
                // ê° êµì‹¤ë§ˆë‹¤ ë¬´ì‘ìœ„ ì±…ìƒ 3~4ê°œì”© ë°°ì¹˜ (ìˆ¨ê±°ë‚˜ ë°©í•´ë¬¼)
                for(let j=0; j<4; j++) {
                    walls.push({ id: "desk", x: startX + 200 + Math.random()*600, y: 0 + Math.random()*200, w: 100, h: 50 });
                }
            }

            // [C] ì§€í•˜ ì—°êµ¬ì†Œ êµ¬ì—­ (ì•„ë˜ë¡œ ê¹Šê²Œ ë»—ì€ ë¯¸ë¡œ)
            // 7ë²ˆ êµì‹¤(x: 8900) ì•„ë˜ë¡œ ë‚´ë ¤ê°€ëŠ” ê±°ëŒ€í•œ ê¸¸
            walls.push({ id: "wall", x: 8900, y: 800, w: 50, h: 2000 });
            walls.push({ id: "wall", x: 9500, y: 800, w: 50, h: 2000 });
            labels.push({ text: "â†“ ì§€í•˜ ë³´ì•ˆì‹¤ êµ¬ì—­", x: 9200, y: 700, size: 50, color: "rgba(255,68,68,0.3)" });

            // ì§€í•˜ ì—°êµ¬ì†Œ ë„“ì€ ë°©
            walls.push({ id: "wall", x: 8000, y: 2800, w: 2000, h: 50 }); // ë°© ìœ—ë²½
            walls.push({ id: "wall", x: 8000, y: 3800, w: 2000, h: 50 }); // ë°© ì•„ë«ë²½
            walls.push({ id: "wall", x: 8000, y: 2800, w: 50, h: 1050 }); // ë°© ì™¼ë²½
            walls.push({ id: "wall", x: 10000, y: 2800, w: 50, h: 1050 }); // ë°© ì˜¤ë¥¸ë²½

            // ë³´ì•ˆ ê²Œì´íŠ¸ (ì ê¸´ ë¬¸)
            walls.push({ id: "security_gate", x: 14000, y: -200, w: 50, h: 550 }); 
            labels.push({ text: "êµì¥ì‹¤ (í†µì œêµ¬ì—­)", x: 14500, y: 200, size: 60, color: "rgba(255,255,255,0.2)" });

            // [D] ìŠ¤í† ë¦¬ ì•„ì´í…œ ë°°ì¹˜ (ë™ì„ ì´ ì—„ì²­ ê¹ë‹ˆë‹¤!)
            interactables.push({ id: "weapon", x: 7000, y: 100, radius: 20, color: "#ffeb3b", active: true, story: weaponStory }); // 6ë°˜ êµì‹¤
            interactables.push({ id: "console", x: 9000, y: 3300, radius: 30, color: "#ff8800", active: true, story: consoleStory }); // ì§€í•˜ ì—°êµ¬ì†Œ ë
            interactables.push({ id: "master_key", x: 15000, y: 100, radius: 20, color: "#ff4444", active: true, story: keyStory }); // ë§µ ìš°ì¸¡ ë êµì¥ì‹¤
        }

        // === 4. ìŠ¤í† ë¦¬ ë¼ì¸ ===
        const introStory = [
            { speaker: "ë‚˜", color: "#fff", text: "(ë¯¸ì¹œ ë“¯ì´ ë„“ì€ í•™êµë‹¤. ë³µë„ê°€ ëì´ ë³´ì´ì§€ ì•Šì•„...)" },
            { speaker: "ë‚˜", color: "#fff", text: "ì–´ë”˜ê°€ì— ë¬´ê¸°ê°€ ìˆì„ ê±°ì•¼. êµì‹¤ë“¤ì„ í•˜ë‚˜ì”© ë’¤ì ¸ë³´ë©° ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê°€ë³´ì." }
        ];

        const weaponStory = [
            { speaker: "ì‹œìŠ¤í…œ", color: "#ffeb3b", text: "[ì¤‘ê¸°ê´€ì´] íšë“! (ì¢Œí´ë¦­ ê¾¹ ëˆ„ë¥´ë©´ ì—„ì²­ë‚œ ì—°ì‚¬!)" },
            { speaker: "ë‚˜", color: "#fff", text: "ì—„ì²­ë‚œ ë¬´ê²Œë‹¤. ì´ê±¸ë¡œ ê´´ë¬¼ë“¤ì„ ë‹¤ ê°ˆì•„ë²„ë¦´ ìˆ˜ ìˆê² ì–´." },
            { speaker: "ë‚˜", color: "#fff", text: "ì˜¤ë¥¸ìª½ ë³µë„ ë êµì¥ì‹¤ì´ ì ê²¨ ìˆì—ˆì§€. [ì§€í•˜ ë³´ì•ˆì‹¤]ë¡œ ë‚´ë ¤ê°€ì„œ ì ê¸ˆì¥ì¹˜ë¥¼ í’€ì!" }
        ];

        const consoleStory = [
            { speaker: "ë³´ì•ˆ ì½˜ì†”", color: "#00ffcc", text: "ã€í•´í‚¹ì„ ì‹œì‘í•©ë‹ˆë‹¤. ê²½ë³´ ì‹œìŠ¤í…œì´ ì‘ë™í•©ë‹ˆë‹¤.ã€" },
            { speaker: "ì‹œìŠ¤í…œ", color: "#ff4444", text: "[ê²½ê³ ] ì‚¬ë°©ì—ì„œ ì‹¤í—˜ì²´ë“¤ì´ ì ‘ê·¼í•©ë‹ˆë‹¤! 60ì´ˆê°„ ìƒì¡´í•˜ì‹­ì‹œì˜¤!" },
            { speaker: "ë‚˜", color: "#fff", text: "ê¸°ê´€ì´ ì¥ì „ ì™„ë£Œ. ë‹¤ ë¤ë²¼ë¼!!" }
        ];

        const keyStory = [
            { speaker: "ì‹œìŠ¤í…œ", color: "#ffeb3b", text: "[ì ˆëŒ€ ë§ˆìŠ¤í„° í‚¤] íšë“! ì²˜ìŒ ì‹œì‘í•œ [ì™¼ìª½ ë ì¶œêµ¬]ë¡œ íƒˆì¶œí•˜ì‹­ì‹œì˜¤." },
            { speaker: "ë‚˜", color: "#fff", text: "ì¢‹ì•„, ì´ì œ ëŒì•„ê°€ê¸°ë§Œ í•˜ë©´... (ìš°ë¥´ë¦‰... ì½°ì•™!!)" },
            { speaker: "ì‹œìŠ¤í…œ", color: "#ff4444", text: "[ê²½ê³ ] ì´ˆê±°ëŒ€ ëŒì—°ë³€ì´ê°€ ê¹¨ì–´ë‚¬ìŠµë‹ˆë‹¤." },
            { speaker: "ë‚˜", color: "#fff", text: "ë¯¸ì¹œ, ì €ê²Œ ë­ì•¼!! 15000 í”½ì…€ì„ ë‹¤ì‹œ ëŒì•„ê°€ì•¼ í•œë‹¤ê³ ?! ì£½ì–´ë¼ ë›°ì–´!!!" }
        ];

        let currentStory = []; let currentLine = 0; let isTyping = false; let textInterval;

        function startDialogue(storyData, onComplete = null) {
            gameState = "STORY"; currentStory = storyData; currentLine = 0;
            dialogueBox.style.display = "flex"; dialogueBox.onComplete = onComplete; showDialogue();
        }

        function typeWriter(text, i) {
            if (i < text.length) { textEl.innerHTML += text.charAt(i); textInterval = setTimeout(() => typeWriter(text, i + 1), 20); } 
            else { isTyping = false; }
        }

        function showDialogue() {
            if (currentLine >= currentStory.length) {
                dialogueBox.style.display = 'none'; gameState = "EXPLORE";
                if (dialogueBox.onComplete) { dialogueBox.onComplete(); dialogueBox.onComplete = null; }
                return;
            }
            isTyping = true; const line = currentStory[currentLine];
            speakerEl.innerText = line.speaker; speakerEl.style.color = line.color;
            textEl.innerHTML = ""; typeWriter(line.text, 0);
        }

        dialogueBox.addEventListener("click", () => {
            if (isTyping) { clearTimeout(textInterval); textEl.innerHTML = currentStory[currentLine].text; isTyping = false; } 
            else { currentLine++; showDialogue(); }
        });

        // === 5. ê²Œì„ ë¡œì§ (ì—…ë°ì´íŠ¸) ===
        function checkCollision(obj, nx, ny) {
            for (let w of walls) {
                if (nx + obj.radius > w.x && nx - obj.radius < w.x + w.w && ny + obj.radius > w.y && ny - obj.radius < w.y + w.h) { return true; }
            }
            return false;
        }

        function update() {
            if (gameState === "EXPLORE") {
                // í”Œë ˆì´ì–´ ì´ë™
                let nextX = player.x; let nextY = player.y;
                if (keys["KeyW"]) nextY -= player.speed;
                if (keys["KeyS"]) nextY += player.speed;
                if (keys["KeyA"]) nextX -= player.speed;
                if (keys["KeyD"]) nextX += player.speed;
                if (!checkCollision(player, nextX, player.y)) player.x = nextX;
                if (!checkCollision(player, player.x, nextY)) player.y = nextY;

                camera.x = player.x - window.innerWidth / 2;
                camera.y = player.y - window.innerHeight / 2;

                // ì´ ë°œì‚¬ (ì‚¬ìš´ë“œ ì¶”ê°€)
                if (player.hasWeapon && isMouseDown) {
                    const now = Date.now();
                    if (now - lastShotTime > fireRate) {
                        const worldMouseX = mouse.x + camera.x; const worldMouseY = mouse.y + camera.y;
                        const spread = (Math.random() - 0.5) * 0.3; // ë°˜ë™ì´ ì‹¬í•¨
                        const angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x) + spread;
                        bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle) * 35, vy: Math.sin(angle) * 35, radius: 4 });
                        playShootSound(); // ì´ì†Œë¦¬ ì¬ìƒ!
                        lastShotTime = now;
                    }
                }

                // ì´ì•Œ ì´ë™
                for (let i = bullets.length - 1; i >= 0; i--) {
                    let b = bullets[i]; b.x += b.vx; b.y += b.vy;
                    let hitWall = false;
                    for (let w of walls) { if (b.x > w.x && b.x < w.x + w.w && b.y > w.y && b.y < w.y + w.h) { hitWall = true; break; } }
                    if (hitWall || Math.hypot(b.x - player.x, b.y - player.y) > 1500) { bullets.splice(i, 1); }
                }

                // ë””íœìŠ¤ ëª¨ë“œ (ì§€í•˜ ì—°êµ¬ì†Œ)
                if (isSurvivalActive) {
                    let elapsed = (Date.now() - survivalStartTime) / 1000;
                    let timeLeft = 60 - elapsed;
                    
                    if (timeLeft <= 0) {
                        isSurvivalActive = false; timerBox.style.display = "none";
                        missionStatus.innerText = "ëª©í‘œ: êµì¥ì‹¤ ê²Œì´íŠ¸ê°€ ì—´ë ¸ìŠµë‹ˆë‹¤! ì§€ìƒìœ¼ë¡œ ì˜¬ë¼ê°€ ìš°ì¸¡ ëìœ¼ë¡œ ê°€ì„¸ìš”.";
                        walls = walls.filter(w => w.id !== "security_gate"); // ë¬¸ ì—´ë¦¼
                    } else {
                        timerBox.innerText = timeLeft.toFixed(2);
                        // ì§€í•˜ ì—°êµ¬ì†Œ ë„“ì€ ë°© ì•ˆì—ì„œ ì‚¬ë°©ì—ì„œ ìŠ¤í°
                        if (Date.now() - lastSpawnTime > 2500) { // 2.5ì´ˆë§ˆë‹¤ 3ë§ˆë¦¬ì”© ìŠ¤í° (ë‚œì´ë„ ê·¹ìƒ)
                            for(let k=0; k<3; k++) {
                                let angle = Math.random() * Math.PI * 2;
                                monsters.push({ 
                                    x: player.x + Math.cos(angle) * 800, y: player.y + Math.sin(angle) * 800, 
                                    radius: 20, speed: 5, hp: 5, isInvincible: false, color: "#800080" 
                                });
                            }
                            lastSpawnTime = Date.now();
                        }
                    }
                }

                // ëª¬ìŠ¤í„° AI
                for (let i = monsters.length - 1; i >= 0; i--) {
                    let m = monsters[i];
                    const angle = Math.atan2(player.y - m.y, player.x - m.x);
                    let mNextX = m.x + Math.cos(angle) * m.speed; let mNextY = m.y + Math.sin(angle) * m.speed;
                    
                    if (!checkCollision(m, mNextX, m.y)) m.x = mNextX;
                    if (!checkCollision(m, m.x, mNextY)) m.y = mNextY;

                    for (let j = bullets.length - 1; j >= 0; j--) {
                        let b = bullets[j];
                        if (Math.hypot(b.x - m.x, b.y - m.y) < m.radius + b.radius) {
                            bullets.splice(j, 1);
                            if (!m.isInvincible) { 
                                m.hp--; if (m.hp <= 0) { monsters.splice(i, 1); break; }
                            }
                        }
                    }
                    if (monsters[i] && Math.hypot(player.x - m.x, player.y - m.y) < player.radius + m.radius) {
                        player.x -= Math.cos(angle) * 20; // ë„‰ë°±
                    }
                }

                // ì•„ì´í…œ íšë“
                let canInteract = false;
                interactables.forEach(item => {
                    if (item.active && Math.hypot(player.x - item.x, player.y - item.y) < 100) { 
                        canInteract = true;
                        if (keys["KeyE"]) {
                            item.active = false; keys["KeyE"] = false; 
                            
                            if (item.id === "weapon") {
                                player.hasWeapon = true; weaponStatus.style.display = "block";
                                weaponStatus.innerText = "ë¬´ê¸°: ì¤‘ê¸°ê´€ì´ (ë§ˆìš°ìŠ¤ ê¾¹!)";
                                missionStatus.innerText = "ëª©í‘œ: ë§µ 7ë°˜ ì•„ë˜ [ì§€í•˜ êµ¬ì—­]ìœ¼ë¡œ ë‚´ë ¤ê°€ ë³´ì•ˆ ì½˜ì†”ì„ ì°¾ìœ¼ì„¸ìš”.";
                                startDialogue(item.story, () => {
                                    // ë¬´ê¸° ë¨¹ìœ¼ë©´ ì”ì±™ì´ ëª‡ ë§ˆë¦¬ ìŠ¤í°
                                    for(let k=0; k<5; k++) monsters.push({ x: player.x - 1000 - k*200, y: 500, radius: 20, speed: 4, hp: 4, isInvincible: false, color: "#800080" });
                                });
                            } 
                            else if (item.id === "console") {
                                startDialogue(item.story, () => {
                                    isSurvivalActive = true; survivalStartTime = Date.now(); lastSpawnTime = Date.now();
                                    timerBox.style.display = "block";
                                    missionStatus.innerText = "ëª©í‘œ: ëê¹Œì§€ ë²„í‹°ì„¸ìš”!!"; missionStatus.style.color = "#ff4444";
                                });
                            }
                            else if (item.id === "master_key") {
                                missionStatus.innerText = "ëª©í‘œ: ë’¤ëŒì•„ë³´ì§€ ë§ê³  15000í”½ì…€ ë°– ì‹œì‘ ì§€ì ìœ¼ë¡œ ë›°ì–´!!!"; missionStatus.style.color = "#ff4444";
                                startDialogue(item.story, () => {
                                    isChaseActive = true; warningBox.style.display = "block";
                                    playScreamSound(); // ê´´ë¬¼ ë¹„ëª…ì†Œë¦¬ ì«™!
                                    
                                    // ì´ˆê±°ëŒ€ ë³´ìŠ¤ ìŠ¤í° (ì†ë„ 7.5ë¡œ ì—„ì²­ ë¹ ë¦„)
                                    monsters.push({ x: 15500, y: 250, radius: 80, speed: 7.5, hp: 99999, isInvincible: true, color: "#ff0000" });
                                    
                                    // ëŒì•„ê°€ëŠ” ê¸¸(0 ~ 14000) ê³³ê³³ì— ë°©í•´ê¾¼ 50ë§ˆë¦¬ ìŠ¤í°!
                                    for(let k=1000; k<14000; k+=300) { 
                                        monsters.push({ x: k, y: 500, radius: 20, speed: 4, hp: 3, isInvincible: false, color: "#800080" }); 
                                    }
                                });
                            }
                        }
                    }
                });
                promptEl.style.display = canInteract ? "block" : "none";
                
                // ìŠ¹ë¦¬: ì²˜ìŒ ì‹œì‘í•œ ì™¼ìª½ ë(x < 100) ë„ì°©
                if (isChaseActive && player.x < 100 && player.y < 1000) {
                    gameState = "WIN"; alert("ğŸ† ìƒìƒì´ˆì›” 15000í”½ì…€ ëŒ€íƒˆì¶œ ì„±ê³µ!! ë‹¹ì‹ ì˜ ì¸ë‚´ë ¥ê³¼ ìƒì¡´ë ¥ì— ë°•ìˆ˜ë¥¼ ë³´ëƒ…ë‹ˆë‹¤."); location.reload();
                }
            }
        }

        // === 6. ë Œë”ë§ ===
        function draw() {
            ctx.fillStyle = "#050508"; ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            ctx.save(); ctx.translate(-camera.x, -camera.y);

            // ê²©ìë¬´ëŠ¬ ë°”ë‹¥ (ê±°ëŒ€ ìŠ¤ì¼€ì¼)
            ctx.strokeStyle = "#111"; ctx.lineWidth = 2;
            for(let i=-1000; i<16000; i+=200) { ctx.beginPath(); ctx.moveTo(i,-1000); ctx.lineTo(i,5000); ctx.stroke(); }
            for(let i=-1000; i<5000; i+=200) { ctx.beginPath(); ctx.moveTo(-1000,i); ctx.lineTo(16000,i); ctx.stroke(); }

            // ë°”ë‹¥ ê¸€ì”¨ (ê·¸ë˜í”½)
            labels.forEach(lbl => {
                ctx.font = `bold ${lbl.size}px 'Nanum Gothic'`;
                ctx.fillStyle = lbl.color;
                ctx.textAlign = "center";
                ctx.fillText(lbl.text, lbl.x, lbl.y);
            });

            // ë²½ & ì±…ìƒ
            ctx.fillStyle = "#1a1a1a";
            walls.forEach(w => { 
                ctx.fillStyle = w.id === "security_gate" ? "rgba(0, 255, 204, 0.5)" : "#1a1a1a"; 
                ctx.fillRect(w.x, w.y, w.w, w.h); 
                ctx.strokeStyle = w.id === "desk" ? "#333" : "#000"; 
                ctx.strokeRect(w.x, w.y, w.w, w.h); 
            });

            // ì•„ì´í…œ
            interactables.forEach(item => {
                if (item.active) {
                    ctx.shadowBlur = 30; ctx.shadowColor = item.color; ctx.fillStyle = item.color;
                    ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; 
                }
            });

            // ëª¬ìŠ¤í„°
            monsters.forEach(m => { ctx.fillStyle = m.color; ctx.beginPath(); ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2); ctx.fill(); });
            
            // ì´ì•Œ
            ctx.fillStyle = "#fff"; bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); ctx.fill(); });
            
            // í”Œë ˆì´ì–´
            ctx.fillStyle = "#00ffcc"; ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2); ctx.fill();
            ctx.restore(); 

            // ì¡°ëª… ìº”ë²„ìŠ¤ (ì–´ë‘ )
            lightCtx.globalCompositeOperation = "source-over";
            let darkness = gameState === "STORY" ? "rgba(0,0,0,1)" : "rgba(0, 0, 5, 0.98)";
            if (isChaseActive && Math.random() > 0.8) darkness = "rgba(50, 0, 0, 0.95)"; 
            if (isSurvivalActive && Math.random() > 0.9) darkness = "rgba(0, 50, 50, 0.95)"; 

            lightCtx.fillStyle = darkness; lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

            if (gameState === "EXPLORE") {
                lightCtx.globalCompositeOperation = "destination-out";
                const screenPlayerX = window.innerWidth / 2; const screenPlayerY = window.innerHeight / 2;
                const worldMouseX = mouse.x + camera.x; const worldMouseY = mouse.y + camera.y;
                const angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);
                
                // ì†ì „ë“± (ì—„ì²­ ë°ê³  ë„“ê²Œ)
                const gradient = lightCtx.createRadialGradient(screenPlayerX, screenPlayerY, 0, screenPlayerX, screenPlayerY, 1200);
                gradient.addColorStop(0, "rgba(255, 255, 255, 1)");   
                gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.8)"); 
                gradient.addColorStop(1, "rgba(255, 255, 255, 0)");   

                lightCtx.fillStyle = gradient; lightCtx.beginPath(); lightCtx.moveTo(screenPlayerX, screenPlayerY);
                const beamWidth = isChaseActive ? 0.8 + Math.random()*0.1 : 1.2; 
                lightCtx.arc(screenPlayerX, screenPlayerY, 1200, angle - beamWidth, angle + beamWidth); 
                lightCtx.lineTo(screenPlayerX, screenPlayerY); lightCtx.fill();
                
                // ë‚´ ì£¼ë³€ ì‹œì•¼
                lightCtx.beginPath(); lightCtx.arc(screenPlayerX, screenPlayerY, 200, 0, Math.PI * 2);
                lightCtx.fillStyle = "rgba(255, 255, 255, 0.6)"; lightCtx.fill();

                // ëª¬ìŠ¤í„° ì•ˆê´‘
                monsters.forEach(m => {
                    lightCtx.beginPath(); lightCtx.arc(m.x - camera.x, m.y - camera.y, m.radius * 1.5, 0, Math.PI * 2);
                    lightCtx.fillStyle = m.isInvincible ? "rgba(255, 0, 0, 0.8)" : "rgba(255, 0, 255, 0.3)"; lightCtx.fill();
                });
            }

            // ê±°ëŒ€ ë¯¸ë‹ˆë§µ
            if (gameState === "EXPLORE") {
                lightCtx.globalCompositeOperation = "source-over";
                const mmW = 400; const mmH = 120; 
                const mmX = window.innerWidth - mmW - 20; const mmY = 20;

                lightCtx.fillStyle = "rgba(0, 0, 0, 0.8)"; lightCtx.fillRect(mmX, mmY, mmW, mmH);
                lightCtx.strokeStyle = "#444"; lightCtx.lineWidth = 2; lightCtx.strokeRect(mmX, mmY, mmW, mmH);

                const mapStartX = -1000; const mapStartY = -1000;
                const mapWidth = 17000; const mapHeight = 5000; 
                const scaleX = mmW / mapWidth; const scaleY = mmH / mapHeight;

                lightCtx.fillStyle = "#666";
                walls.forEach(w => {
                    lightCtx.fillStyle = w.id === "security_gate" ? "#00ffcc" : "#666";
                    lightCtx.fillRect(mmX + (w.x - mapStartX) * scaleX, mmY + (w.y - mapStartY) * scaleY, w.w * scaleX, w.h * scaleY);
                });

                interactables.forEach(item => {
                    if(item.active) {
                        lightCtx.fillStyle = item.color; lightCtx.beginPath();
                        lightCtx.arc(mmX + (item.x - mapStartX) * scaleX, mmY + (item.y - mapStartY) * scaleY, 4, 0, Math.PI*2); lightCtx.fill();
                    }
                });

                lightCtx.fillStyle = "#ff4444";
                monsters.forEach(m => {
                    lightCtx.beginPath(); lightCtx.arc(mmX + (m.x - mapStartX) * scaleX, mmY + (m.y - mapStartY) * scaleY, m.isInvincible ? 6 : 3, 0, Math.PI*2); lightCtx.fill();
                });

                lightCtx.fillStyle = "#00ffcc"; lightCtx.beginPath();
                lightCtx.arc(mmX + (player.x - mapStartX) * scaleX, mmY + (player.y - mapStartY) * scaleY, 5, 0, Math.PI*2); lightCtx.fill();
            }

            if(gameState !== "START") requestAnimationFrame(() => { update(); draw(); });
        }

        // ê²Œì„ ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì‹œ
        function initGame() {
            document.getElementById("start-screen").style.display = "none";
            document.getElementById("game-container").style.display = "block";
            initAudio(); // ë¸Œë¼ìš°ì € ì •ì±…ìƒ ì‚¬ìš©ì í´ë¦­ ì‹œ ì˜¤ë””ì˜¤ í™œì„±í™”
            buildHugeMap(); // ê±°ëŒ€ ë§µ ìƒì„±
            startDialogue(introStory); 
            draw();
        }
    </script>
</body>
</html>
